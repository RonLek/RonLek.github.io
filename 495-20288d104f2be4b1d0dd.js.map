{"version":3,"file":"495-20288d104f2be4b1d0dd.js","mappings":"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","sources":["webpack://rohan-lekhwani-gatsby-website/./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js","webpack://rohan-lekhwani-gatsby-website/../src/components/intersection-observer.ts","webpack://rohan-lekhwani-gatsby-website/../src/components/lazy-hydrate.tsx"],"sourcesContent":["function asyncGeneratorStep(n, t, e, r, o, a, c) {\n  try {\n    var i = n[a](c),\n      u = i.value;\n  } catch (n) {\n    return void e(n);\n  }\n  i.done ? t(u) : Promise.resolve(u).then(r, o);\n}\nfunction _asyncToGenerator(n) {\n  return function () {\n    var t = this,\n      e = arguments;\n    return new Promise(function (r, o) {\n      var a = n.apply(t, e);\n      function _next(n) {\n        asyncGeneratorStep(a, r, o, _next, _throw, \"next\", n);\n      }\n      function _throw(n) {\n        asyncGeneratorStep(a, r, o, _next, _throw, \"throw\", n);\n      }\n      _next(void 0);\n    });\n  };\n}\nexport { _asyncToGenerator as default };","let intersectionObserver: IntersectionObserver\n\nexport type Unobserver = () => void\n\nconst ioEntryMap = new WeakMap<HTMLElement, () => void>()\n/* eslint-disable @typescript-eslint/no-explicit-any  */\nconst connection =\n  (navigator as any).connection ||\n  (navigator as any).mozConnection ||\n  (navigator as any).webkitConnection\n/* eslint-enable @typescript-eslint/no-explicit-any */\n\n// These match the thresholds used in Chrome's native lazy loading\n// @see https://web.dev/browser-level-image-lazy-loading/#distance-from-viewport-thresholds\nconst FAST_CONNECTION_THRESHOLD = `1250px`\nconst SLOW_CONNECTION_THRESHOLD = `2500px`\n\nexport function createIntersectionObserver(\n  callback: () => void\n): (element: HTMLElement) => Unobserver {\n  const connectionType = connection?.effectiveType\n\n  // if we don't support intersectionObserver we don't lazy load (Sorry IE 11).\n  if (!(`IntersectionObserver` in window)) {\n    return function observe(): Unobserver {\n      callback()\n      return function unobserve(): void {}\n    }\n  }\n\n  if (!intersectionObserver) {\n    intersectionObserver = new IntersectionObserver(\n      entries => {\n        entries.forEach(entry => {\n          if (entry.isIntersecting) {\n            // Get the matching entry's callback and call it\n            ioEntryMap.get(entry.target as HTMLElement)?.()\n            // We only need to call it once\n            ioEntryMap.delete(entry.target as HTMLElement)\n          }\n        })\n      },\n      {\n        rootMargin:\n          connectionType === `4g` && !connection?.saveData\n            ? FAST_CONNECTION_THRESHOLD\n            : SLOW_CONNECTION_THRESHOLD,\n      }\n    )\n  }\n\n  return function observe(element: HTMLElement): Unobserver {\n    // Store a reference to the callback mapped to the element being watched\n    ioEntryMap.set(element, callback)\n    intersectionObserver.observe(element)\n\n    return function unobserve(): void {\n      if (intersectionObserver && element) {\n        ioEntryMap.delete(element)\n        intersectionObserver.unobserve(element)\n      }\n    }\n  }\n}\n","import React from \"react\"\nimport { renderToStaticMarkup } from \"react-dom/server\"\nimport { LayoutWrapper } from \"./layout-wrapper\"\nimport { Placeholder } from \"./placeholder\"\nimport { MainImage } from \"./main-image\"\nimport {\n  hasNativeLazyLoadSupport,\n  getMainProps,\n  getPlaceholderProps,\n} from \"./hooks\"\nimport { createIntersectionObserver } from \"./intersection-observer\"\nimport type { MainImageProps } from \"./main-image\"\nimport type { GatsbyImageProps } from \"./gatsby-image.browser\"\n\ntype LazyHydrateProps = Omit<GatsbyImageProps, \"as\" | \"style\" | \"className\"> & {\n  isLoading: boolean\n  isLoaded: boolean\n}\n\nasync function applyPolyfill(element: HTMLImageElement): Promise<void> {\n  if (!(`objectFitPolyfill` in window)) {\n    await import(\n      // @ts-ignore typescript can't find the module for some reason ¯\\_(ツ)_/¯\n      /* webpackChunkName: \"gatsby-plugin-image-objectfit-polyfill\" */ `objectFitPolyfill`\n    )\n  }\n  ;(window as any).objectFitPolyfill(element)\n}\n\nfunction toggleLoaded(\n  mainImage: HTMLElement,\n  placeholderImage: HTMLElement\n): void {\n  mainImage.style.opacity = `1`\n\n  if (placeholderImage) {\n    placeholderImage.style.opacity = `0`\n  }\n}\n\nfunction startLoading(\n  element: HTMLElement,\n  cacheKey: string,\n  imageCache: Set<string>,\n  onStartLoad: GatsbyImageProps[\"onStartLoad\"],\n  onLoad: GatsbyImageProps[\"onLoad\"],\n  onError: GatsbyImageProps[\"onError\"]\n): () => void {\n  const mainImage = element.querySelector(\n    `[data-main-image]`\n  ) as HTMLImageElement\n  const placeholderImage = element.querySelector<HTMLElement>(\n    `[data-placeholder-image]`\n  )\n  const isCached = imageCache.has(cacheKey)\n\n  function onImageLoaded(e): void {\n    // eslint-disable-next-line @babel/no-invalid-this\n    this.removeEventListener(`load`, onImageLoaded)\n\n    const target = e.currentTarget\n    const img = new Image()\n    img.src = target.currentSrc\n\n    if (img.decode) {\n      // Decode the image through javascript to support our transition\n      img\n        .decode()\n        .then(() => {\n          // eslint-disable-next-line @babel/no-invalid-this\n          toggleLoaded(this, placeholderImage)\n          onLoad?.({\n            wasCached: isCached,\n          })\n        })\n        .catch(e => {\n          // eslint-disable-next-line @babel/no-invalid-this\n          toggleLoaded(this, placeholderImage)\n          onError?.(e)\n        })\n    } else {\n      // eslint-disable-next-line @babel/no-invalid-this\n      toggleLoaded(this, placeholderImage)\n      onLoad?.({\n        wasCached: isCached,\n      })\n    }\n  }\n\n  mainImage.addEventListener(`load`, onImageLoaded)\n\n  onStartLoad?.({\n    wasCached: isCached,\n  })\n  Array.from(mainImage.parentElement.children).forEach(child => {\n    const src = child.getAttribute(`data-src`)\n    const srcSet = child.getAttribute(`data-srcset`)\n    if (src) {\n      child.removeAttribute(`data-src`)\n      child.setAttribute(`src`, src)\n    }\n    if (srcSet) {\n      child.removeAttribute(`data-srcset`)\n      child.setAttribute(`srcset`, srcSet)\n    }\n  })\n\n  imageCache.add(cacheKey)\n\n  // Load times not always fires - mostly when it's a 304\n  // We check if the image is already completed and if so we trigger onload.\n  if (mainImage.complete) {\n    onImageLoaded.call(mainImage, {\n      currentTarget: mainImage,\n    })\n  }\n\n  return (): void => {\n    if (mainImage) {\n      mainImage.removeEventListener(`load`, onImageLoaded)\n    }\n  }\n}\n\nexport function swapPlaceholderImage(\n  element: HTMLElement,\n  cacheKey: string,\n  imageCache: Set<string>,\n  style: React.CSSProperties,\n  onStartLoad: GatsbyImageProps[\"onStartLoad\"],\n  onLoad: GatsbyImageProps[\"onLoad\"],\n  onError: GatsbyImageProps[\"onError\"]\n): () => void {\n  if (!hasNativeLazyLoadSupport()) {\n    let cleanup\n    const io = createIntersectionObserver(() => {\n      cleanup = startLoading(\n        element,\n        cacheKey,\n        imageCache,\n        onStartLoad,\n        onLoad,\n        onError\n      )\n    })\n    const unobserve = io(element)\n\n    // Polyfill \"object-fit\" if unsupported (mostly IE)\n    if (!(`objectFit` in document.documentElement.style)) {\n      element.dataset.objectFit = style.objectFit ?? `cover`\n      element.dataset.objectPosition = `${style.objectPosition ?? `50% 50%`}`\n      applyPolyfill(element as HTMLImageElement)\n    }\n\n    return (): void => {\n      if (cleanup) {\n        cleanup()\n      }\n\n      unobserve()\n    }\n  }\n\n  return startLoading(\n    element,\n    cacheKey,\n    imageCache,\n    onStartLoad,\n    onLoad,\n    onError\n  )\n}\n\nexport function renderImageToString({\n  image,\n  loading = `lazy`,\n  isLoading,\n  isLoaded,\n  imgClassName,\n  imgStyle = {},\n  objectPosition,\n  backgroundColor,\n  objectFit = `cover`,\n  ...props\n}: LazyHydrateProps): string {\n  const {\n    width,\n    height,\n    layout,\n    images,\n    placeholder,\n    backgroundColor: wrapperBackgroundColor,\n  } = image\n\n  imgStyle = {\n    objectFit,\n    objectPosition,\n    backgroundColor,\n    ...imgStyle,\n  }\n\n  return renderToStaticMarkup(\n    <LayoutWrapper layout={layout} width={width} height={height}>\n      <Placeholder\n        {...getPlaceholderProps(\n          placeholder,\n          isLoaded,\n          layout,\n          width,\n          height,\n          wrapperBackgroundColor,\n          objectFit,\n          objectPosition\n        )}\n      />\n\n      <MainImage\n        {...(props as Omit<\n          MainImageProps,\n          \"images\" | \"fallback\" | \"onLoad\" | \"onError\"\n        >)}\n        width={width}\n        height={height}\n        className={imgClassName}\n        {...getMainProps(isLoading, isLoaded, images, loading, imgStyle)}\n      />\n    </LayoutWrapper>\n  )\n}\n"],"names":["asyncGeneratorStep","n","t","e","r","o","a","c","i","u","value","done","Promise","resolve","then","d","WeakMap","m","navigator","connection","mozConnection","webkitConnection","g","b","style","opacity","h","querySelector","s","has","l","_this","this","removeEventListener","currentTarget","Image","src","currentSrc","decode","wasCached","catch","addEventListener","Array","from","parentElement","children","forEach","getAttribute","removeAttribute","setAttribute","add","complete","call","v","window","IntersectionObserver","isIntersecting","get","target","delete","rootMargin","effectiveType","saveData","set","observe","unobserve","document","documentElement","dataset","objectFit","objectPosition","_ref","arguments","apply","_next","_throw","_asyncToGenerator","_regeneratorRuntime","_callee","_context","prev","next","t0","objectFitPolyfill","stop","_x","f","image","_e$loading","loading","isLoading","isLoaded","imgClassName","_e$imgStyle","imgStyle","p","backgroundColor","_e$objectFit","y","w","j","width","C","height","E","layout","F","images","P","placeholder","L","className"],"sourceRoot":""}